day05回顾:
  for 语句:
    for x in "ABCDE":
        print(x)

    以下的结果是: 5,6,7,8....19
    for x in range(10) and range(5,20):
        print(x)

  range函数:
      x = range(10)  # 生成0,1,2,3,4...
      y = [0,1,2,3,4,5,6,7,8,9]
    range(stop)
    range(start, stop)
    range(start, stop, step)
continue 语句
   在while语句和for语句中 运行结果不同?
      while 中 跳转到真值表达式处
      for 中 跳转到向可迭代对象取数据处

列表:
  表示方式:
    []
  列表是一种可变的，可以存储任意数据类型的容器
  列表是序列

  list()
  list(iterable)
      示例:
         list('hello')
         list(range(10))
         list([2,3,5,7])  # 复制一个列表

  运算:
    + += * *=
    < <= > >= == !=
    in / not in 
    索引 index 和 切片 slice

day06笔记：
列表的 in / not in 运算符
  in 判断一个对象是否存在于容器内，如果存在返回True,否则返回False
  用法同字符串的 in 相同

  语法:
    数据对象 in 容器

  示例：
    L = [1, 'Two', 3.3, '四'] 
    1 in L  # True
    2 in L  # False
    3.3 in L  # True
    '4' not in L  # True

列表的索引：
  语法:
    列表[整数表达式]
  用法:
    取值时，等同于字符串的索引操作
    索引分为正向索引和反向索引，规则与字符串索引规则完全相同

  列表的索引赋值
    列表是可变的序列，可以通过索引赋值改变列表中的元素
  示例:
    L = [1,2,3,4]
    L[2] = 3.3  # 将第三个元素改为 3.3

列表的切片
  语法:
    列表[:]
    列表[::]
    列表的切片取值时，返回一个列表，规则等同于字符串切片规则

列表的切片赋值:
  作用：
    可以改变原列表的排序，可以插入和修改数据
    可以用切片改变列表的对应元素的值
  语法:
    列表[切片] = 可迭代对象
    注: 赋值运算符的右侧必须是一个可迭代对象
  示例:
    L = [2, 3, 4]
    L[0:1] = [1.1, 2.2]  # L = [1.1,2.2,3,4]
    L = [2, 3, 4]
    L[1:] = [3.3, 4.4, 5.5]#L=[2,3.3,4.4,5.5]
    L = [2, 3, 4]
    L[:] = [0, 1]  # L = [0, 1]
    L = [2, 4]  # 实现中间插入 [3.1, 3.2]
    L[1:1]  = [3.1, 3.2] # L = [2,3.1,3.2,4]
    L = [2,3,4] # 实现在前面插入[0,1]
    L[0:0] = [0, 1]
    L = [2,3,4]  # 实现在后面插入[5,6]
    L[-1:-1]  = [5, 6]
    L = [1,4]  # 用range函数生成的可迭代对象赋值
    L[1:1] = range(2,4)
    L = [2,3,4]
    L[1:2] = "ABCD"  # "ABCD"也是可迭代对象
  切片赋值注意事项:
    对于步长不等于1的切片赋值，赋值运算符右侧的可迭代对象提供的元素个数一定要等于切片切出的段数
    例:
      L = [1,2,3,4,5,6]
      L[::2] = "ABC"  # 对的
      # 以下切出三段，但给出5个元素填充是错的
      L[::2] = "ABCDE"

del 语句  用于删除列表中的元素
  语法
    del 序列[整数表达式]
    del 序列[切片]
  示例:
    L = [1,2,3,4,5,6]
    del L[-1]  # 删除最后一个 6
    del L[0]  # 删除第1个 1
    del L[::2]  # 删除 2,4

python3常用于序列的函数:
  len(seq)  返回容器的元素个数
  max(x)    返回序列的最大值元素
  min(x)    返回序列的最小值元素
  sum(x)    返回序列中所有元素的和(元素必须是数值类型)
  any(x)    真值测试, 如果容器内其中一个值为True则返回True,否则返回False
  all(x)    真值测试, 容器内所有元素的布尔值为True才返回True

python3 中常用的列表方法(method)
  详见:
    >>> help(list)
    或：
    /python_base_docs_html/list_xxxxx.html

练习：
  写一个程序，让用户输入很多个正整数，当输入小于零的数时结束输入
  1)  输出这些数的和
  2)  输出这些数的最大的数和第二大的数
  3)  删除最小的一个数
  4)  按原来输入的顺序打印出乘余的这些数


浅拷贝 shallow copy 和 深拷贝 deep copy
浅拷贝:
    是指复制过程中，只复制一层变量，不会复制深层变量绑定的对象的复制过程
  示例:
    L = [3.1, 3.2]
    L1 = [1, 2, L]  #[1, 2, [3.1, 3.2]]
    L2 = L1.copy()  #[1, 2, [3.1, 3.2]]浅拷贝
    L[0] = 3.14
    L1  # [1, 2, [3.14, 3.2]]  
    L2  # [1, 2, [3.14, 3.2]] 为什么变为3.14？
    # L1[2] 和 L2[2] 共同拥有 L绑定的对象
深拷贝:
  示例:
    import copy  # 导放copy模块
    L = [3.1, 3.2]
    L1 = [1, 2, L]  #[1, 2, [3.1, 3.2]]
    L2 = copy.deepcopy(L1)  # 深拷贝
    L[0] = 3.14
    L1  # [1, 2, [3.14, 3.2]]  
    L2  # [1, 2, [3.1, 3.2]] 此列表不受影响

  注：
    深拷贝通常只对可变对象进行深层复制，不可变对象通常不会被复制

理解:
  import copy # 导入复制模块
  L1 = [1, 2, [3.1, 3.2]]
  L2 = L1  # 会发生什么? 
  L3 = L1.copy()  # 会发生什么
  L4 = copy.deepcopy(L1)  # 会发生什么？
  问题:
    如何把L1 里的3.1 改为3.14
    L1[2][0] = 3.14

列表与字符串比较:
  1. 列表和字符串都是序列，元素之间有先后关系
  2. 字符串是不可变的序列，而列表是可变的序列
  3. 字符串中每个元素只能存储字符，而列表可以存储任意类型的元素
  4. 列表和字符串都是可迭代对象

字符串文本解析方法 split 和 join
  S.split(sep=None)  将字符串使用sep作为分隔符分割S字符串，返回分割后的字符串列表，当不给定参数时，用空白字符作为分隔符分割
  S.join(iterable)  用可迭代对象中的字符串，返回一个中间用S进行分隔的字符串

  示例：
    s = 'Beijing is capital'
    L = s.split(' ') # L = ['Beijing', 'is', 'capital']

    L = ["C:", "Programe files", "Python3"]
    s = '\\'.join(L)
    # s = "C:\\Programe files\\Python3"

练习：
  有字符串"hello" , 生成'h e l l o' 和 'h-e-l-l-o'
  (用交互模式完成)

列表推导式 list comprehension
  列表推导式是用可迭代对象依次生成带有多个元素的列表的表达式

  作用：
    用简易方法生成列表
  语法:
    [表达式 for 变量 in 可迭代对象]
    或
    [表达式 for 变量 in 可迭代对象 if 真值表达式]

  问题：
    如何生成下列列表?
    [1, 4, 9, 16, 25, .... 81]
    L = []
    for x in range(1, 10):
        L.append(x ** 2)

    # 用列表推导式生成:
      L = [x**2 for x in range(1, 10)]

练习：
  用列表推导式生成 1~100 内奇数的列表
   [x for x in range(1, 100, 2)]

  示例：
    生成[1, 9, 25, 49, 81] 列表，跳过所有的偶数
    [x ** 2 for x in range(1, 10) if x % 2 == 1]

练习:
  输入一个数值作为开始的数 用begin绑定
  再输入一个结束的整数用end 绑定
    将 开始 至 结束的数中，平方加1 能被5 整除的数放入列表中
  请输入开始数: 1
  请输入结束数: 20
    n 如果 (n ** 2 + 1) % 5 == 0则把n加入列表中
  结果:
    [2,3,7,8,12,13....]


列表推导式的嵌套:
  语法:
    [表达式1 
      for 变量1 in 可迭代对象1 if 真值表达式1
        for 变量2 in 可迭代对象2 if 真值表达式2]

  示例：
    想生成
      ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
    [x + y for x in 'ABC' for y in '123']

练习：
  1. 输入一个整数n 代表结束的数.
  将 1 ~ n之间所有的素数计算出来并存入到列表L 中
    1) 最后打印此列表中的全部素数
    2) 打印这些素数的和

  2. 求 100 以内有哪儿些整数与自身+1 的乘积 再对 11求余的结果等于8?
       x * (x + 1) % 11 == 8
    打印这些数，
    将这些数存于列表中（偿试使用列表推导式)
  3. 计算 20 个百斐波那契数( fabonacci 数) 存于列表中，最后打印这20个数
    1, 1, 2, 3, 5, 8, 13, ...
      (从第三个数起，后一个数是前两个数之和)
      




