前情回顾

本地套接字 ： 本地进程间实现通信
socket（AF_UNIX,SOCK_STREAM）

进程 ：一次执行的过程

进程特征和概念 
PCB  虚拟内存   PID  父子进程   孤儿进程  僵尸进程

ps -aux    pa -ajx    top   nice   renice

进程的状态  
三态  五态


fork（）
多程序 ： 无法根据情况动态创建进程
通过接口创建进程：便于控制，可以在程序运行中随时根据需要创建

getpid  getppid    sys.exit   os._exit

处理僵尸进程 
1.让父进程先结束
2.父进程处理子进程的退出
	wait  waitpid
	处理信号

3. 创建二级子进程
********************************************
os.waitpid(pid,option)
功能： 处理子进程的退出
参数： pid ：  -1  表示等待任意的子进程退出
               >0  表示等待相应PID号的子进程
			 option： 0  表示阻塞等待
			         WNOHANG ：表示非阻塞等待
返回值： 同 wait
os.waitpid(-1,0) ==== os.wait()

创建二级子进程

父进程创建子进程后等待子进程退出
子进程创建二级子进程后马上退出，二级子进程成为孤儿
让父进程和二级子进程处理具体事件


群聊聊天室

*选择使用什么样的套接字

udp   

转发 客户端 ---》 服务器  ---》 其他客户端
用print简单打印命令操作提示
存储用户    列表  字典
使用函数或者类来包装功能
没完成一个功能检测一个功能


*功能描述

#类似于qq群聊 ，用户在加入聊天室时有一个简单的登录
输入用户名即可
实现 ： 客户端输入用户名，发送给服务器，服务器存储

#需要个数据结构保存用户
收到发过来的用户名 放到列表或者字典中


#当一个人发送消息 其他人可以接受消息 
  张三 ： xxxxxx
实现 ： 客户将消息发送给服务器，服务器遍历列表，进行转发

#当一个人登录 退出时给其他人一些提示 
 xxx  login
 xxx  logout
实现：给服务器发送登录退出消息，服务器转发

# 管理员发送消息 全部在线成员均可收到
实现 ： 服务端可控制消息发送，给所有人

server:
def login:
def chat:

def main()


multiprocessing 模块创建进程 标准库

1. 需要将事件封装为函数
2. 使用multiprocessing提供的类创建新进程
3. 新的进程和对应的函数相关联，进程启动会自动执行函数，完成事件
4. 进程回收

创建子进程类
multiprocessing.Process()
功能 ： 创建子进程
参数 ： name ： 给创建的进程起一个名字 
                默认 process-1
        target ： 目标函数
				args ：元组  要给函数传递的参数  位置
				kwargs ： 字典  要给函数传递的参数 键值

进程对象属性函数
p.start() 
功能 ： 启动子进程  此时进程真正创建

p.join([timeout])
功能 ： 阻塞等待回收相应的子进程
参数 ： 默认为阻塞，timeout为超时时间

p的其他属性
p.name  进程名称
p.pid   创建的进程的PID号
p.is_alive()  进程状态

p.daemon 
默认值为False 表示主进程结束后 不影响子进程的执行
如果设置为True 则主进程执行完毕所有的子进程一同退出

* 设置必须在 start()前
* 一般使用daemon = True时不用加join
* 该属性并不是 linux/unix系统中所说的守护进程设置

守护进程 ： 生命周期长，随系统创建随系统销毁。
            不受前端控制，后台运行
						操作系统进程，或者是自动化运行进程居多

作业 ： 编写一个程序，使用multiprocessing
        要求创建两个进程来复制一个文件，各复制一半（以字节来分）



